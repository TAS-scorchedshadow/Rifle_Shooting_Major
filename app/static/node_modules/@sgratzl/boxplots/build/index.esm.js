/**
 * @sgratzl/boxplots
 * https://github.com/sgratzl/boxplots
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

function quantilesInterpolate(arr, length, interpolate) {
    const n1 = length - 1;
    const compute = (q) => {
        const index = q * n1;
        const lo = Math.floor(index);
        const h = index - lo;
        const a = arr[lo];
        return h === 0 ? a : interpolate(a, arr[Math.min(lo + 1, n1)], h);
    };
    return {
        q1: compute(0.25),
        median: compute(0.5),
        q3: compute(0.75),
    };
}
function quantilesType7(arr, length = arr.length) {
    return quantilesInterpolate(arr, length, (a, b, alpha) => a + alpha * (b - a));
}
function quantilesLinear(arr, length = arr.length) {
    return quantilesInterpolate(arr, length, (i, j, fraction) => i + (j - i) * fraction);
}
function quantilesLower(arr, length = arr.length) {
    return quantilesInterpolate(arr, length, (i) => i);
}
function quantilesHigher(arr, length = arr.length) {
    return quantilesInterpolate(arr, length, (_, j) => j);
}
function quantilesNearest(arr, length = arr.length) {
    return quantilesInterpolate(arr, length, (i, j, fraction) => (fraction < 0.5 ? i : j));
}
function quantilesMidpoint(arr, length = arr.length) {
    return quantilesInterpolate(arr, length, (i, j) => (i + j) * 0.5);
}
function quantilesFivenum(arr, length = arr.length) {
    const n = length;
    const n4 = Math.floor((n + 3) / 2) / 2;
    const compute = (d) => 0.5 * (arr[Math.floor(d) - 1] + arr[Math.ceil(d) - 1]);
    return {
        q1: compute(n4),
        median: compute((n + 1) / 2),
        q3: compute(n + 1 - n4),
    };
}
function quantilesHinges(arr, length = arr.length) {
    return quantilesFivenum(arr, length);
}

function createSortedData(data) {
    let min = Number.POSITIVE_INFINITY;
    let max = Number.NEGATIVE_INFINITY;
    let sum = 0;
    let valid = 0;
    const length = data.length;
    const vs = data instanceof Float64Array ? new Float64Array(length) : new Float32Array(length);
    for (let i = 0; i < length; ++i) {
        const v = data[i];
        if (v == null || Number.isNaN(v)) {
            continue;
        }
        vs[valid] = v;
        valid++;
        if (v < min) {
            min = v;
        }
        if (v > max) {
            max = v;
        }
        sum += v;
    }
    const missing = length - valid;
    if (valid === 0) {
        return {
            sum,
            min,
            max,
            missing,
            s: [],
        };
    }
    const s = valid === length ? vs : vs.subarray(0, valid);
    s.sort((a, b) => (a === b ? 0 : a < b ? -1 : 1));
    return {
        sum,
        min: s[0],
        max: s[s.length - 1],
        missing,
        s,
    };
}
function withSortedData(data) {
    if (data.length === 0) {
        return {
            sum: Number.NaN,
            min: Number.NaN,
            max: Number.NaN,
            missing: 0,
            s: [],
        };
    }
    const min = data[0];
    const max = data[data.length - 1];
    const red = (acc, v) => acc + v;
    const sum = data instanceof Float32Array
        ? data.reduce(red, 0)
        : data instanceof Float64Array
            ? data.reduce(red, 0)
            : data.reduce(red, 0);
    return {
        sum,
        min,
        max,
        missing: 0,
        s: data,
    };
}
function boxplot(data, options = {}) {
    const { quantiles, validAndSorted, coef, whiskersMode, eps } = Object.assign({
        coef: 1.5,
        eps: 10e-3,
        quantiles: quantilesType7,
        validAndSorted: false,
        whiskersMode: 'nearest',
    }, options);
    const { missing, s, min, max, sum } = validAndSorted ? withSortedData(data) : createSortedData(data);
    const invalid = {
        min: Number.NaN,
        max: Number.NaN,
        mean: Number.NaN,
        missing,
        iqr: Number.NaN,
        count: data.length,
        whiskerHigh: Number.NaN,
        whiskerLow: Number.NaN,
        outlier: [],
        median: Number.NaN,
        q1: Number.NaN,
        q3: Number.NaN,
        items: [],
    };
    const same = (a, b) => Math.abs(a - b) < eps;
    const valid = data.length - missing;
    if (valid === 0) {
        return invalid;
    }
    const { median, q1, q3 } = quantiles(s, valid);
    const iqr = q3 - q1;
    const isCoefValid = typeof coef === 'number' && coef > 0;
    let whiskerLow = isCoefValid ? Math.max(min, q1 - coef * iqr) : min;
    let whiskerHigh = isCoefValid ? Math.min(max, q3 + coef * iqr) : max;
    const outlier = [];
    for (let i = 0; i < valid; ++i) {
        const v = s[i];
        if (v >= whiskerLow || same(v, whiskerLow)) {
            if (whiskersMode === 'nearest') {
                whiskerLow = v;
            }
            break;
        }
        if (outlier.length === 0 || !same(outlier[outlier.length - 1], v)) {
            outlier.push(v);
        }
    }
    const reversedOutliers = [];
    for (let i = valid - 1; i >= 0; --i) {
        const v = s[i];
        if (v <= whiskerHigh || same(v, whiskerHigh)) {
            if (whiskersMode === 'nearest') {
                whiskerHigh = v;
            }
            break;
        }
        if ((reversedOutliers.length === 0 || !same(reversedOutliers[reversedOutliers.length - 1], v)) &&
            (outlier.length === 0 || !same(outlier[outlier.length - 1], v))) {
            reversedOutliers.push(v);
        }
    }
    return {
        min,
        max,
        count: data.length,
        missing,
        mean: sum / valid,
        whiskerHigh,
        whiskerLow,
        outlier: outlier.concat(reversedOutliers.reverse()),
        median,
        q1,
        q3,
        iqr,
        items: s,
    };
}

export default boxplot;
export { boxplot, quantilesFivenum, quantilesHigher, quantilesHinges, quantilesInterpolate, quantilesLinear, quantilesLower, quantilesMidpoint, quantilesNearest, quantilesType7 };
//# sourceMappingURL=index.esm.js.map
